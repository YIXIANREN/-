# 算法图解

## 1.算法简介

### 二分查找

#### 简述

<u>**二分查找是一种算法，其输入是一个有序的元素列表(必须有序的原因稍后解释)。如果要 查找的元素包含在列表中，二分查找返回其位置;否则返回null。**</u>

#### 步数

对于包含n个元素的列表

简单查找：最多 n

二分查找：最多logn 2为底

#### python代码

leetcode [704. 二分查找](https://leetcode-cn.com/problems/binary-search/)

```python
class Solution(object):
    def search(self, nums, target):
        """
        :type nums: List[int]
        :type target: int
        :rtype: int
        """
        low = 0
        high = len(nums)-1
        while low <= high:
            mid = (high+low)//2
            midv = nums[mid]
            if target<midv:
                high = mid-1
            if target>midv:
                low = mid+1
            if target == midv:
                return mid
        return -1
```

tips:

low<=high; mid+-1; 3/2=1

只返回首次遇到的return值；

// 代表整除3//2=1

### 运行时间

#### 常见运行时间

下面按从快到慢的顺序列出了你经常会遇到的5种大O运行时间。

- **O(log n)**，也叫对数时间，这样的算法包括二分查找。
- **O(n)**，也叫线性时间，这样的算法包括简单查找。
- **O(n * log n)**，这样的算法包括第4章将介绍的快速排序——一种速度较快的排序算法。
- **O(n2)**，这样的算法包括第2章将介绍的选择排序——一种速度较慢的排序算法。
- **O(n!)**，这样的算法包括接下来将介绍的旅行商问题的解决方案——一种非常慢的算法。

#### 启示

- 算法的速度指的并非时间，而是操作数的增速。
- 谈论算法的速度时，我们说的是随着输入的增加，其运行时间将以什么样的速度增加。 
- 算法的运行时间用大O表示法表示。（大O表示法指出了最糟情况下的运行时间；除最糟情况下的运行时间外，还应考虑平均情况的运行时间，这很重要。最糟情况和平 均情况将在第4章讨论。）
- O(log n)比O(n)快，当需要搜索的元素越多时，前者比后者快得越多。

### 旅行商

### 小结

- 二分查找的速度比简单查找快得多。
- O(log n)比O(n)快。需要搜索的元素越多，前者比后者就快得越多。  算法运行时间并不以秒为单位。
- 算法运行时间是从其增速的角度度量的。
- 算法运行时间用大O表示法表示。

## 2.选择排序

### 内存工作原理

### 数组和链表

需要存储多项数据时，有两种基本方式——数组和链表。

链表擅长插入和删除；数组擅长随机访问（数组用0开始的索引表示位置）。

|      | 数组 | 链表 |
| ---- | ---- | ---- |
| 读取 | O(1) | O(n) |
| 插入 | O(n) | O(1) |
| 删除 | O(n) | O(1) |

### 选择排序

时间：
$$
O(n^2)
$$
选择排序是一种灵巧的算法，但其速度不是很快。快速排序是一种更快的排序算法，其运行 时间为O(n log n)，这将在下一章介绍。

#### python代码

leetcode[912. 排序数组](https://leetcode-cn.com/problems/sort-an-array/)

```python
class Solution(object):
    def smallest(self, arr):
        smallv = arr[0]
        smalli = 0
        for i in range(0,len(arr)):
            if arr[i]<smallv:
                smallv = arr[i]
                smalli = i
        return smalli
    def sortArray(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        n = len(nums)
        sortednum = []
        for i in range(0,n):
            sortednum.append(nums.pop(self.smallest(nums)))
        return sortednum
```

### 小结

- 计算机内存犹如一大堆抽屉。
- 需要存储多个元素时，可使用数组或链表。
- 数组的元素都在一起。
- 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。
- 数组的读取速度很快。
- 链表的插入和删除速度很快。
- 在同一个数组中，所有元素的类型都必须相同(都为int、double等)。

## 3.递归

### 基线条件和递归条件

递归条件是指函数调用自己，基线条件指的是函数不再调用自己。

### 栈

#### 调用栈

#### 递归调用栈

### 小结

- 递归指的是调用自己的函数。
- 每个递归函数都有两个条件:基线条件和递归条件。  栈有两种操作:压入和弹出。
- 所有函数调用都进入调用栈。
- 调用栈可能很长，这将占用大量的内存。

## 4.快速排序

### 分而治之

使用D&C策略的两个步骤：

1. 找出基线条件，这种条件必须尽可能简单。 *编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素*
2. 不断将问题分解（或者说缩小规模），直到符合基线条件

#### 练习

4.1 请编写前述sum函数的代码。

```python
def sum1(arr):
    if arr == []:
        return 0
    else:
        return arr[0]+sum1(arr[1:])
```

4.2 编写一个递归函数来计算列表包含的元素数。

```python
def len1(arr):
    if arr == []:
        return 0
    else:
        return 1+len1(arr[1:])
```

4.3 找出列表中最大的数字。

```python
def max1(arr):
    if len(arr) == 2:
        if arr[0]>arr[1]:
            return arr[0]
        else:
            return arr[1]
    else:
        submax = max1(arr[1:])
        if submax>arr[0]:
            return submax
        else:
            return arr[0]
```

```python
def max1(arr):
    if len(arr) == 2:
        return arr[0] if arr[0]>arr[1] else arr[1]
    else:
        submax = max1(arr[1:])
        return submax if submax>arr[0] else arr[0]
```

Tips:

Return a if... else b; 只能用于一个判断条件

4.4 还记得第1章介绍的二分查找吗?它也是一种分而治之算法。你能 9 找出二分查找算法的基线条件和递归条件吗?

```python
def search(arr,target):
    if len(arr)==1:
        return True if arr[0]==target else False
    else:
        if target<arr[len(arr)//2]:
            return search(arr[:len(arr)//2],target)
        elif target==arr[len(arr)//2]:
            return True
        else:
            return search(arr[len(arr)//2:],target)
```

Tips:

切片a[:n]指索引0到n-1的列表

切片a[n:]指索引n到最后的列表

切片a[n:m]指 索引n到m-1的列表

a[1,-1]截取第2到倒数第二个元素

### 快速排序

